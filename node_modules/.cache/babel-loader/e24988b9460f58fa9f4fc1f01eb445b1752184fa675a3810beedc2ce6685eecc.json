{"ast":null,"code":"/**\n * Argon2 KDF from RFC 9106. Can be used to create a key from password and salt.\n * We suggest to use Scrypt. JS Argon is 2-10x slower than native code because of 64-bitness:\n * * argon uses uint64, but JS doesn't have fast uint64array\n * * uint64 multiplication is 1/3 of time\n * * `P` function would be very nice with u64, because most of value will be in registers,\n *   hovewer with u32 it will require 32 registers, which is too much.\n * * JS arrays do slow bound checks, so reading from `A2_BUF` slows it down\n * @module\n */\nimport { add3H, add3L, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL } from \"./_u64.js\";\nimport { blake2b } from \"./blake2.js\";\nimport { abytes, clean, kdfInputToBytes, nextTick, u32, u8 } from \"./utils.js\";\nconst AT = {\n  Argond2d: 0,\n  Argon2i: 1,\n  Argon2id: 2\n};\nconst ARGON2_SYNC_POINTS = 4;\nconst abytesOrZero = buf => {\n  if (buf === undefined) return Uint8Array.of();\n  return kdfInputToBytes(buf);\n};\n// u32 * u32 = u64\nfunction mul(a, b) {\n  const aL = a & 0xffff;\n  const aH = a >>> 16;\n  const bL = b & 0xffff;\n  const bH = b >>> 16;\n  const ll = Math.imul(aL, bL);\n  const hl = Math.imul(aH, bL);\n  const lh = Math.imul(aL, bH);\n  const hh = Math.imul(aH, bH);\n  const carry = (ll >>> 16) + (hl & 0xffff) + lh;\n  const high = hh + (hl >>> 16) + (carry >>> 16) | 0;\n  const low = carry << 16 | ll & 0xffff;\n  return {\n    h: high,\n    l: low\n  };\n}\nfunction mul2(a, b) {\n  // 2 * a * b (via shifts)\n  const {\n    h,\n    l\n  } = mul(a, b);\n  return {\n    h: (h << 1 | l >>> 31) & 4294967295,\n    l: l << 1 & 4294967295\n  };\n}\n// BlaMka permutation for Argon2\n// A + B + (2 * u32(A) * u32(B))\nfunction blamka(Ah, Al, Bh, Bl) {\n  const {\n    h: Ch,\n    l: Cl\n  } = mul2(Al, Bl);\n  // A + B + (2 * A * B)\n  const Rll = add3L(Al, Bl, Cl);\n  return {\n    h: add3H(Rll, Ah, Bh, Ch),\n    l: Rll | 0\n  };\n}\n// Temporary block buffer\nconst A2_BUF = new Uint32Array(256); // 1024 bytes (matrix 16x16)\nfunction G(a, b, c, d) {\n  let Al = A2_BUF[2 * a],\n    Ah = A2_BUF[2 * a + 1]; // prettier-ignore\n  let Bl = A2_BUF[2 * b],\n    Bh = A2_BUF[2 * b + 1]; // prettier-ignore\n  let Cl = A2_BUF[2 * c],\n    Ch = A2_BUF[2 * c + 1]; // prettier-ignore\n  let Dl = A2_BUF[2 * d],\n    Dh = A2_BUF[2 * d + 1]; // prettier-ignore\n  ({\n    h: Ah,\n    l: Al\n  } = blamka(Ah, Al, Bh, Bl));\n  ({\n    Dh,\n    Dl\n  } = {\n    Dh: Dh ^ Ah,\n    Dl: Dl ^ Al\n  });\n  ({\n    Dh,\n    Dl\n  } = {\n    Dh: rotr32H(Dh, Dl),\n    Dl: rotr32L(Dh, Dl)\n  });\n  ({\n    h: Ch,\n    l: Cl\n  } = blamka(Ch, Cl, Dh, Dl));\n  ({\n    Bh,\n    Bl\n  } = {\n    Bh: Bh ^ Ch,\n    Bl: Bl ^ Cl\n  });\n  ({\n    Bh,\n    Bl\n  } = {\n    Bh: rotrSH(Bh, Bl, 24),\n    Bl: rotrSL(Bh, Bl, 24)\n  });\n  ({\n    h: Ah,\n    l: Al\n  } = blamka(Ah, Al, Bh, Bl));\n  ({\n    Dh,\n    Dl\n  } = {\n    Dh: Dh ^ Ah,\n    Dl: Dl ^ Al\n  });\n  ({\n    Dh,\n    Dl\n  } = {\n    Dh: rotrSH(Dh, Dl, 16),\n    Dl: rotrSL(Dh, Dl, 16)\n  });\n  ({\n    h: Ch,\n    l: Cl\n  } = blamka(Ch, Cl, Dh, Dl));\n  ({\n    Bh,\n    Bl\n  } = {\n    Bh: Bh ^ Ch,\n    Bl: Bl ^ Cl\n  });\n  ({\n    Bh,\n    Bl\n  } = {\n    Bh: rotrBH(Bh, Bl, 63),\n    Bl: rotrBL(Bh, Bl, 63)\n  });\n  A2_BUF[2 * a] = Al, A2_BUF[2 * a + 1] = Ah;\n  A2_BUF[2 * b] = Bl, A2_BUF[2 * b + 1] = Bh;\n  A2_BUF[2 * c] = Cl, A2_BUF[2 * c + 1] = Ch;\n  A2_BUF[2 * d] = Dl, A2_BUF[2 * d + 1] = Dh;\n}\n// prettier-ignore\nfunction P(v00, v01, v02, v03, v04, v05, v06, v07, v08, v09, v10, v11, v12, v13, v14, v15) {\n  G(v00, v04, v08, v12);\n  G(v01, v05, v09, v13);\n  G(v02, v06, v10, v14);\n  G(v03, v07, v11, v15);\n  G(v00, v05, v10, v15);\n  G(v01, v06, v11, v12);\n  G(v02, v07, v08, v13);\n  G(v03, v04, v09, v14);\n}\nfunction block(x, xPos, yPos, outPos, needXor) {\n  for (let i = 0; i < 256; i++) A2_BUF[i] = x[xPos + i] ^ x[yPos + i];\n  // columns (8)\n  for (let i = 0; i < 128; i += 16) {\n    // prettier-ignore\n    P(i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15);\n  }\n  // rows (8)\n  for (let i = 0; i < 16; i += 2) {\n    // prettier-ignore\n    P(i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49, i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113);\n  }\n  if (needXor) for (let i = 0; i < 256; i++) x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];else for (let i = 0; i < 256; i++) x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  clean(A2_BUF);\n}\n// Variable-Length Hash Function H'\nfunction Hp(A, dkLen) {\n  const A8 = u8(A);\n  const T = new Uint32Array(1);\n  const T8 = u8(T);\n  T[0] = dkLen;\n  // Fast path\n  if (dkLen <= 64) return blake2b.create({\n    dkLen\n  }).update(T8).update(A8).digest();\n  const out = new Uint8Array(dkLen);\n  let V = blake2b.create({}).update(T8).update(A8).digest();\n  let pos = 0;\n  // First block\n  out.set(V.subarray(0, 32));\n  pos += 32;\n  // Rest blocks\n  for (; dkLen - pos > 64; pos += 32) {\n    const Vh = blake2b.create({}).update(V);\n    Vh.digestInto(V);\n    Vh.destroy();\n    out.set(V.subarray(0, 32), pos);\n  }\n  // Last block\n  out.set(blake2b(V, {\n    dkLen: dkLen - pos\n  }), pos);\n  clean(V, T);\n  return u32(out);\n}\n// Used only inside process block!\nfunction indexAlpha(r, s, laneLen, segmentLen, index, randL, sameLane = false) {\n  // This is ugly, but close enough to reference implementation.\n  let area;\n  if (r === 0) {\n    if (s === 0) area = index - 1;else if (sameLane) area = s * segmentLen + index - 1;else area = s * segmentLen + (index == 0 ? -1 : 0);\n  } else if (sameLane) area = laneLen - segmentLen + index - 1;else area = laneLen - segmentLen + (index == 0 ? -1 : 0);\n  const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;\n  const rel = area - 1 - mul(area, mul(randL, randL).h).h;\n  return (startPos + rel) % laneLen;\n}\nconst maxUint32 = Math.pow(2, 32);\nfunction isU32(num) {\n  return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;\n}\nfunction argon2Opts(opts) {\n  const merged = {\n    version: 0x13,\n    dkLen: 32,\n    maxmem: maxUint32 - 1,\n    asyncTick: 10\n  };\n  for (let [k, v] of Object.entries(opts)) if (v != null) merged[k] = v;\n  const {\n    dkLen,\n    p,\n    m,\n    t,\n    version,\n    onProgress\n  } = merged;\n  if (!isU32(dkLen) || dkLen < 4) throw new Error('dkLen should be at least 4 bytes');\n  if (!isU32(p) || p < 1 || p >= Math.pow(2, 24)) throw new Error('p should be 1 <= p < 2^24');\n  if (!isU32(m)) throw new Error('m should be 0 <= m < 2^32');\n  if (!isU32(t) || t < 1) throw new Error('t (iterations) should be 1 <= t < 2^32');\n  if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');\n  /*\n  Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n  */\n  if (!isU32(m) || m < 8 * p) throw new Error('memory should be at least 8*p bytes');\n  if (version !== 0x10 && version !== 0x13) throw new Error('unknown version=' + version);\n  return merged;\n}\nfunction argon2Init(password, salt, type, opts) {\n  password = kdfInputToBytes(password);\n  salt = kdfInputToBytes(salt);\n  abytes(password);\n  abytes(salt);\n  if (!isU32(password.length)) throw new Error('password should be less than 4 GB');\n  if (!isU32(salt.length) || salt.length < 8) throw new Error('salt should be at least 8 bytes and less than 4 GB');\n  if (!Object.values(AT).includes(type)) throw new Error('invalid type');\n  let {\n    p,\n    dkLen,\n    m,\n    t,\n    version,\n    key,\n    personalization,\n    maxmem,\n    onProgress,\n    asyncTick\n  } = argon2Opts(opts);\n  // Validation\n  key = abytesOrZero(key);\n  personalization = abytesOrZero(personalization);\n  // H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n  //       LE32(v) || LE32(y) || LE32(length(P)) || P ||\n  //       LE32(length(S)) || S ||  LE32(length(K)) || K ||\n  //       LE32(length(X)) || X)\n  const h = blake2b.create({});\n  const BUF = new Uint32Array(1);\n  const BUF8 = u8(BUF);\n  for (let item of [p, dkLen, m, t, version, type]) {\n    BUF[0] = item;\n    h.update(BUF8);\n  }\n  for (let i of [password, salt, key, personalization]) {\n    BUF[0] = i.length; // BUF is u32 array, this is valid\n    h.update(BUF8).update(i);\n  }\n  const H0 = new Uint32Array(18);\n  const H0_8 = u8(H0);\n  h.digestInto(H0_8);\n  // 256 u32 = 1024 (BLOCK_SIZE), fills A2_BUF on processing\n  // Params\n  const lanes = p;\n  // m' = 4 * p * floor (m / 4p)\n  const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));\n  //q = m' / p columns\n  const laneLen = Math.floor(mP / p);\n  const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);\n  const memUsed = mP * 256;\n  if (!isU32(maxmem) || memUsed > maxmem) throw new Error('mem should be less than 2**32, got: maxmem=' + maxmem + ', memused=' + memUsed);\n  const B = new Uint32Array(memUsed);\n  // Fill first blocks\n  for (let l = 0; l < p; l++) {\n    const i = 256 * laneLen * l;\n    // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n    H0[17] = l;\n    H0[16] = 0;\n    B.set(Hp(H0, 1024), i);\n    // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n    H0[16] = 1;\n    B.set(Hp(H0, 1024), i + 256);\n  }\n  let perBlock = () => {};\n  if (onProgress) {\n    const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlock / 10000), 1);\n    let blockCnt = 0;\n    perBlock = () => {\n      blockCnt++;\n      if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock)) onProgress(blockCnt / totalBlock);\n    };\n  }\n  clean(BUF, H0);\n  return {\n    type,\n    mP,\n    p,\n    t,\n    version,\n    B,\n    laneLen,\n    lanes,\n    segmentLen,\n    dkLen,\n    perBlock,\n    asyncTick\n  };\n}\nfunction argon2Output(B, p, laneLen, dkLen) {\n  const B_final = new Uint32Array(256);\n  for (let l = 0; l < p; l++) for (let j = 0; j < 256; j++) B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];\n  const res = u8(Hp(B_final, dkLen));\n  clean(B_final);\n  return res;\n}\nfunction processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor) {\n  if (offset % laneLen) prev = offset - 1;\n  let randL, randH;\n  if (dataIndependent) {\n    let i128 = index % 128;\n    if (i128 === 0) {\n      address[256 + 12]++;\n      block(address, 256, 2 * 256, 0, false);\n      block(address, 0, 2 * 256, 0, false);\n    }\n    randL = address[2 * i128];\n    randH = address[2 * i128 + 1];\n  } else {\n    const T = 256 * prev;\n    randL = B[T];\n    randH = B[T + 1];\n  }\n  // address block\n  const refLane = r === 0 && s === 0 ? l : randH % lanes;\n  const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);\n  const refBlock = laneLen * refLane + refPos;\n  // B[i][j] = G(B[i][j-1], B[l][z])\n  block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);\n}\nfunction argon2(type, password, salt, opts) {\n  const {\n    mP,\n    p,\n    t,\n    version,\n    B,\n    laneLen,\n    lanes,\n    segmentLen,\n    dkLen,\n    perBlock\n  } = argon2Init(password, salt, type, opts);\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || type == AT.Argon2id && r === 0 && s < 2;\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n/** argon2d GPU-resistant version. */\nexport const argon2d = (password, salt, opts) => argon2(AT.Argond2d, password, salt, opts);\n/** argon2i side-channel-resistant version. */\nexport const argon2i = (password, salt, opts) => argon2(AT.Argon2i, password, salt, opts);\n/** argon2id, combining i+d, the most popular version from RFC 9106 */\nexport const argon2id = (password, salt, opts) => argon2(AT.Argon2id, password, salt, opts);\nasync function argon2Async(type, password, salt, opts) {\n  const {\n    mP,\n    p,\n    t,\n    version,\n    B,\n    laneLen,\n    lanes,\n    segmentLen,\n    dkLen,\n    perBlock,\n    asyncTick\n  } = argon2Init(password, salt, type, opts);\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  let ts = Date.now();\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || type == AT.Argon2id && r === 0 && s < 2;\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          const diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < asyncTick)) {\n            await nextTick();\n            ts += diff;\n          }\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n/** argon2d async GPU-resistant version. */\nexport const argon2dAsync = (password, salt, opts) => argon2Async(AT.Argond2d, password, salt, opts);\n/** argon2i async side-channel-resistant version. */\nexport const argon2iAsync = (password, salt, opts) => argon2Async(AT.Argon2i, password, salt, opts);\n/** argon2id async, combining i+d, the most popular version from RFC 9106 */\nexport const argon2idAsync = (password, salt, opts) => argon2Async(AT.Argon2id, password, salt, opts);","map":{"version":3,"names":["add3H","add3L","rotr32H","rotr32L","rotrBH","rotrBL","rotrSH","rotrSL","blake2b","abytes","clean","kdfInputToBytes","nextTick","u32","u8","AT","Argond2d","Argon2i","Argon2id","ARGON2_SYNC_POINTS","abytesOrZero","buf","undefined","Uint8Array","of","mul","a","b","aL","aH","bL","bH","ll","Math","imul","hl","lh","hh","carry","high","low","h","l","mul2","blamka","Ah","Al","Bh","Bl","Ch","Cl","Rll","A2_BUF","Uint32Array","G","c","d","Dl","Dh","P","v00","v01","v02","v03","v04","v05","v06","v07","v08","v09","v10","v11","v12","v13","v14","v15","block","x","xPos","yPos","outPos","needXor","i","Hp","A","dkLen","A8","T","T8","create","update","digest","out","V","pos","set","subarray","Vh","digestInto","destroy","indexAlpha","r","s","laneLen","segmentLen","index","randL","sameLane","area","startPos","rel","maxUint32","pow","isU32","num","Number","isSafeInteger","argon2Opts","opts","merged","version","maxmem","asyncTick","k","v","Object","entries","p","m","t","onProgress","Error","argon2Init","password","salt","type","length","values","includes","key","personalization","BUF","BUF8","item","H0","H0_8","lanes","mP","floor","memUsed","B","perBlock","totalBlock","callbackPer","max","blockCnt","argon2Output","B_final","j","res","processBlock","address","offset","prev","dataIndependent","randH","i128","refLane","refPos","refBlock","argon2","argon2d","argon2i","argon2id","argon2Async","ts","Date","now","diff","argon2dAsync","argon2iAsync","argon2idAsync"],"sources":["C:\\Users\\brian\\OneDrive\\Desktop\\shadow-sidekick-sqlite-vss-poc\\haven-mental-health\\node_modules\\@noble\\hashes\\src\\argon2.ts"],"sourcesContent":["/**\n * Argon2 KDF from RFC 9106. Can be used to create a key from password and salt.\n * We suggest to use Scrypt. JS Argon is 2-10x slower than native code because of 64-bitness:\n * * argon uses uint64, but JS doesn't have fast uint64array\n * * uint64 multiplication is 1/3 of time\n * * `P` function would be very nice with u64, because most of value will be in registers,\n *   hovewer with u32 it will require 32 registers, which is too much.\n * * JS arrays do slow bound checks, so reading from `A2_BUF` slows it down\n * @module\n */\nimport { add3H, add3L, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL } from './_u64.ts';\nimport { blake2b } from './blake2.ts';\nimport { abytes, clean, kdfInputToBytes, nextTick, u32, u8, type KDFInput } from './utils.ts';\n\nconst AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 } as const;\ntype Types = (typeof AT)[keyof typeof AT];\n\nconst ARGON2_SYNC_POINTS = 4;\nconst abytesOrZero = (buf?: KDFInput) => {\n  if (buf === undefined) return Uint8Array.of();\n  return kdfInputToBytes(buf);\n};\n\n// u32 * u32 = u64\nfunction mul(a: number, b: number) {\n  const aL = a & 0xffff;\n  const aH = a >>> 16;\n  const bL = b & 0xffff;\n  const bH = b >>> 16;\n  const ll = Math.imul(aL, bL);\n  const hl = Math.imul(aH, bL);\n  const lh = Math.imul(aL, bH);\n  const hh = Math.imul(aH, bH);\n  const carry = (ll >>> 16) + (hl & 0xffff) + lh;\n  const high = (hh + (hl >>> 16) + (carry >>> 16)) | 0;\n  const low = (carry << 16) | (ll & 0xffff);\n  return { h: high, l: low };\n}\n\nfunction mul2(a: number, b: number) {\n  // 2 * a * b (via shifts)\n  const { h, l } = mul(a, b);\n  return { h: ((h << 1) | (l >>> 31)) & 0xffff_ffff, l: (l << 1) & 0xffff_ffff };\n}\n\n// BlaMka permutation for Argon2\n// A + B + (2 * u32(A) * u32(B))\nfunction blamka(Ah: number, Al: number, Bh: number, Bl: number) {\n  const { h: Ch, l: Cl } = mul2(Al, Bl);\n  // A + B + (2 * A * B)\n  const Rll = add3L(Al, Bl, Cl);\n  return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };\n}\n\n// Temporary block buffer\nconst A2_BUF = new Uint32Array(256); // 1024 bytes (matrix 16x16)\n\nfunction G(a: number, b: number, c: number, d: number) {\n  let Al = A2_BUF[2*a], Ah = A2_BUF[2*a + 1]; // prettier-ignore\n  let Bl = A2_BUF[2*b], Bh = A2_BUF[2*b + 1]; // prettier-ignore\n  let Cl = A2_BUF[2*c], Ch = A2_BUF[2*c + 1]; // prettier-ignore\n  let Dl = A2_BUF[2*d], Dh = A2_BUF[2*d + 1]; // prettier-ignore\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });\n\n  ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));\n  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });\n  ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });\n\n  ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));\n  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });\n  ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });\n\n  (A2_BUF[2 * a] = Al), (A2_BUF[2 * a + 1] = Ah);\n  (A2_BUF[2 * b] = Bl), (A2_BUF[2 * b + 1] = Bh);\n  (A2_BUF[2 * c] = Cl), (A2_BUF[2 * c + 1] = Ch);\n  (A2_BUF[2 * d] = Dl), (A2_BUF[2 * d + 1] = Dh);\n}\n\n// prettier-ignore\nfunction P(\n  v00: number, v01: number, v02: number, v03: number, v04: number, v05: number, v06: number, v07: number,\n  v08: number, v09: number, v10: number, v11: number, v12: number, v13: number, v14: number, v15: number,\n) {\n  G(v00, v04, v08, v12);\n  G(v01, v05, v09, v13);\n  G(v02, v06, v10, v14);\n  G(v03, v07, v11, v15);\n  G(v00, v05, v10, v15);\n  G(v01, v06, v11, v12);\n  G(v02, v07, v08, v13);\n  G(v03, v04, v09, v14);\n}\n\nfunction block(x: Uint32Array, xPos: number, yPos: number, outPos: number, needXor: boolean) {\n  for (let i = 0; i < 256; i++) A2_BUF[i] = x[xPos + i] ^ x[yPos + i];\n  // columns (8)\n  for (let i = 0; i < 128; i += 16) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7,\n      i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15\n    );\n  }\n  // rows (8)\n  for (let i = 0; i < 16; i += 2) {\n    // prettier-ignore\n    P(\n      i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49,\n      i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113\n    );\n  }\n\n  if (needXor) for (let i = 0; i < 256; i++) x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  else for (let i = 0; i < 256; i++) x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];\n  clean(A2_BUF);\n}\n\n// Variable-Length Hash Function H'\nfunction Hp(A: Uint32Array, dkLen: number) {\n  const A8 = u8(A);\n  const T = new Uint32Array(1);\n  const T8 = u8(T);\n  T[0] = dkLen;\n  // Fast path\n  if (dkLen <= 64) return blake2b.create({ dkLen }).update(T8).update(A8).digest();\n  const out = new Uint8Array(dkLen);\n  let V = blake2b.create({}).update(T8).update(A8).digest();\n  let pos = 0;\n  // First block\n  out.set(V.subarray(0, 32));\n  pos += 32;\n  // Rest blocks\n  for (; dkLen - pos > 64; pos += 32) {\n    const Vh = blake2b.create({}).update(V);\n    Vh.digestInto(V);\n    Vh.destroy();\n    out.set(V.subarray(0, 32), pos);\n  }\n  // Last block\n  out.set(blake2b(V, { dkLen: dkLen - pos }), pos);\n  clean(V, T);\n  return u32(out);\n}\n\n// Used only inside process block!\nfunction indexAlpha(\n  r: number,\n  s: number,\n  laneLen: number,\n  segmentLen: number,\n  index: number,\n  randL: number,\n  sameLane: boolean = false\n) {\n  // This is ugly, but close enough to reference implementation.\n  let area: number;\n  if (r === 0) {\n    if (s === 0) area = index - 1;\n    else if (sameLane) area = s * segmentLen + index - 1;\n    else area = s * segmentLen + (index == 0 ? -1 : 0);\n  } else if (sameLane) area = laneLen - segmentLen + index - 1;\n  else area = laneLen - segmentLen + (index == 0 ? -1 : 0);\n  const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;\n  const rel = area - 1 - mul(area, mul(randL, randL).h).h;\n  return (startPos + rel) % laneLen;\n}\n\n/**\n * Argon2 options.\n * * t: time cost, m: mem cost in kb, p: parallelization.\n * * key: optional key. personalization: arbitrary extra data.\n * * dkLen: desired number of output bytes.\n */\nexport type ArgonOpts = {\n  t: number; // Time cost, iterations count\n  m: number; // Memory cost (in KB)\n  p: number; // Parallelization parameter\n  version?: number; // Default: 0x13 (19)\n  key?: KDFInput; // Optional key\n  personalization?: KDFInput; // Optional arbitrary extra data\n  dkLen?: number; // Desired number of returned bytes\n  asyncTick?: number; // Maximum time in ms for which async function can block execution\n  maxmem?: number;\n  onProgress?: (progress: number) => void;\n};\n\nconst maxUint32 = Math.pow(2, 32);\nfunction isU32(num: number) {\n  return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;\n}\n\nfunction argon2Opts(opts: ArgonOpts) {\n  const merged: any = {\n    version: 0x13,\n    dkLen: 32,\n    maxmem: maxUint32 - 1,\n    asyncTick: 10,\n  };\n  for (let [k, v] of Object.entries(opts)) if (v != null) merged[k] = v;\n\n  const { dkLen, p, m, t, version, onProgress } = merged;\n  if (!isU32(dkLen) || dkLen < 4) throw new Error('dkLen should be at least 4 bytes');\n  if (!isU32(p) || p < 1 || p >= Math.pow(2, 24)) throw new Error('p should be 1 <= p < 2^24');\n  if (!isU32(m)) throw new Error('m should be 0 <= m < 2^32');\n  if (!isU32(t) || t < 1) throw new Error('t (iterations) should be 1 <= t < 2^32');\n  if (onProgress !== undefined && typeof onProgress !== 'function')\n    throw new Error('progressCb should be function');\n  /*\n  Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.\n  */\n  if (!isU32(m) || m < 8 * p) throw new Error('memory should be at least 8*p bytes');\n  if (version !== 0x10 && version !== 0x13) throw new Error('unknown version=' + version);\n  return merged;\n}\n\nfunction argon2Init(password: KDFInput, salt: KDFInput, type: Types, opts: ArgonOpts) {\n  password = kdfInputToBytes(password);\n  salt = kdfInputToBytes(salt);\n  abytes(password);\n  abytes(salt);\n  if (!isU32(password.length)) throw new Error('password should be less than 4 GB');\n  if (!isU32(salt.length) || salt.length < 8)\n    throw new Error('salt should be at least 8 bytes and less than 4 GB');\n  if (!Object.values(AT).includes(type)) throw new Error('invalid type');\n  let { p, dkLen, m, t, version, key, personalization, maxmem, onProgress, asyncTick } =\n    argon2Opts(opts);\n\n  // Validation\n  key = abytesOrZero(key);\n  personalization = abytesOrZero(personalization);\n  // H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n  //       LE32(v) || LE32(y) || LE32(length(P)) || P ||\n  //       LE32(length(S)) || S ||  LE32(length(K)) || K ||\n  //       LE32(length(X)) || X)\n  const h = blake2b.create({});\n  const BUF = new Uint32Array(1);\n  const BUF8 = u8(BUF);\n  for (let item of [p, dkLen, m, t, version, type]) {\n    BUF[0] = item;\n    h.update(BUF8);\n  }\n  for (let i of [password, salt, key, personalization]) {\n    BUF[0] = i.length; // BUF is u32 array, this is valid\n    h.update(BUF8).update(i);\n  }\n  const H0 = new Uint32Array(18);\n  const H0_8 = u8(H0);\n  h.digestInto(H0_8);\n  // 256 u32 = 1024 (BLOCK_SIZE), fills A2_BUF on processing\n\n  // Params\n  const lanes = p;\n  // m' = 4 * p * floor (m / 4p)\n  const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));\n  //q = m' / p columns\n  const laneLen = Math.floor(mP / p);\n  const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);\n  const memUsed = mP * 256;\n  if (!isU32(maxmem) || memUsed > maxmem)\n    throw new Error(\n      'mem should be less than 2**32, got: maxmem=' + maxmem + ', memused=' + memUsed\n    );\n  const B = new Uint32Array(memUsed);\n  // Fill first blocks\n  for (let l = 0; l < p; l++) {\n    const i = 256 * laneLen * l;\n    // B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))\n    H0[17] = l;\n    H0[16] = 0;\n    B.set(Hp(H0, 1024), i);\n    // B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))\n    H0[16] = 1;\n    B.set(Hp(H0, 1024), i + 256);\n  }\n  let perBlock = () => {};\n  if (onProgress) {\n    const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;\n    // Invoke callback if progress changes from 10.01 to 10.02\n    // Allows to draw smooth progress bar on up to 8K screen\n    const callbackPer = Math.max(Math.floor(totalBlock / 10000), 1);\n    let blockCnt = 0;\n    perBlock = () => {\n      blockCnt++;\n      if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))\n        onProgress(blockCnt / totalBlock);\n    };\n  }\n  clean(BUF, H0);\n  return { type, mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };\n}\n\nfunction argon2Output(B: Uint32Array, p: number, laneLen: number, dkLen: number) {\n  const B_final = new Uint32Array(256);\n  for (let l = 0; l < p; l++)\n    for (let j = 0; j < 256; j++) B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];\n  const res = u8(Hp(B_final, dkLen));\n  clean(B_final);\n  return res;\n}\n\nfunction processBlock(\n  B: Uint32Array,\n  address: Uint32Array,\n  l: number,\n  r: number,\n  s: number,\n  index: number,\n  laneLen: number,\n  segmentLen: number,\n  lanes: number,\n  offset: number,\n  prev: number,\n  dataIndependent: boolean,\n  needXor: boolean\n) {\n  if (offset % laneLen) prev = offset - 1;\n  let randL, randH;\n  if (dataIndependent) {\n    let i128 = index % 128;\n    if (i128 === 0) {\n      address[256 + 12]++;\n      block(address, 256, 2 * 256, 0, false);\n      block(address, 0, 2 * 256, 0, false);\n    }\n    randL = address[2 * i128];\n    randH = address[2 * i128 + 1];\n  } else {\n    const T = 256 * prev;\n    randL = B[T];\n    randH = B[T + 1];\n  }\n  // address block\n  const refLane = r === 0 && s === 0 ? l : randH % lanes;\n  const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);\n  const refBlock = laneLen * refLane + refPos;\n  // B[i][j] = G(B[i][j-1], B[l][z])\n  block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);\n}\n\nfunction argon2(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock } = argon2Init(\n    password,\n    salt,\n    type,\n    opts\n  );\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d GPU-resistant version. */\nexport const argon2d = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argond2d, password, salt, opts);\n/** argon2i side-channel-resistant version. */\nexport const argon2i = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2i, password, salt, opts);\n/** argon2id, combining i+d, the most popular version from RFC 9106 */\nexport const argon2id = (password: KDFInput, salt: KDFInput, opts: ArgonOpts): Uint8Array =>\n  argon2(AT.Argon2id, password, salt, opts);\n\nasync function argon2Async(type: Types, password: KDFInput, salt: KDFInput, opts: ArgonOpts) {\n  const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick } =\n    argon2Init(password, salt, type, opts);\n  // Pre-loop setup\n  // [address, input, zero_block] format so we can pass single U32 to block function\n  const address = new Uint32Array(3 * 256);\n  address[256 + 6] = mP;\n  address[256 + 8] = t;\n  address[256 + 10] = type;\n  let ts = Date.now();\n  for (let r = 0; r < t; r++) {\n    const needXor = r !== 0 && version === 0x13;\n    address[256 + 0] = r;\n    for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {\n      address[256 + 4] = s;\n      const dataIndependent = type == AT.Argon2i || (type == AT.Argon2id && r === 0 && s < 2);\n      for (let l = 0; l < p; l++) {\n        address[256 + 2] = l;\n        address[256 + 12] = 0;\n        let startPos = 0;\n        if (r === 0 && s === 0) {\n          startPos = 2;\n          if (dataIndependent) {\n            address[256 + 12]++;\n            block(address, 256, 2 * 256, 0, false);\n            block(address, 0, 2 * 256, 0, false);\n          }\n        }\n        // current block postion\n        let offset = l * laneLen + s * segmentLen + startPos;\n        // previous block position\n        let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;\n        for (let index = startPos; index < segmentLen; index++, offset++, prev++) {\n          perBlock();\n          processBlock(\n            B,\n            address,\n            l,\n            r,\n            s,\n            index,\n            laneLen,\n            segmentLen,\n            lanes,\n            offset,\n            prev,\n            dataIndependent,\n            needXor\n          );\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          const diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < asyncTick)) {\n            await nextTick();\n            ts += diff;\n          }\n        }\n      }\n    }\n  }\n  clean(address);\n  return argon2Output(B, p, laneLen, dkLen);\n}\n\n/** argon2d async GPU-resistant version. */\nexport const argon2dAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argond2d, password, salt, opts);\n/** argon2i async side-channel-resistant version. */\nexport const argon2iAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2i, password, salt, opts);\n/** argon2id async, combining i+d, the most popular version from RFC 9106 */\nexport const argon2idAsync = (\n  password: KDFInput,\n  salt: KDFInput,\n  opts: ArgonOpts\n): Promise<Uint8Array> => argon2Async(AT.Argon2id, password, salt, opts);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}