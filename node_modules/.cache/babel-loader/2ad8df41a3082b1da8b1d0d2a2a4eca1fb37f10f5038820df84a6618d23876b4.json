{"ast":null,"code":"// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = password => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\nconst randomBytes = length => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n\n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n\n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n\n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3,\n      // iterations\n      m: 64 * 1024,\n      // memory in KB\n      p: 1 // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true // Only therapists in this app\n    });\n    return {\n      success: true,\n      email\n    };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1\n    });\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000) // 8 hours\n    };\n    this.sessions.set(sessionId, session);\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["simpleHash","password","Buffer","from","toString","randomBytes","length","array","Uint8Array","crypto","getRandomValues","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","set","id","email","name","hash","createdAt","Date","isTherapist","console","log","register","Error","has","salt","argon2id","t","m","p","split","concat","success","login","attempts","get","user","hashBuffer","slice","storedHash","inputHash","valid","compare","delete","sessionId","session","userId","expiresAt","now","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = (password) => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\n\nconst randomBytes = (length) => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3, // iterations\n      m: 64 * 1024, // memory in KB\n      p: 1, // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    \n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1,\n    });\n\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}