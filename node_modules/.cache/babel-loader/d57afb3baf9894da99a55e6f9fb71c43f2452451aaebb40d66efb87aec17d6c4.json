{"ast":null,"code":"/**\n * P2P Service\n * Handles WebRTC peer-to-peer connections\n * Simple signaling through WebSocket, direct data/media channels\n */export class P2PService{constructor(){this.signalingServer=null;this.localPeerId=null;this.iceServers=[{urls:'stun:stun.l.google.com:19302'},{urls:'stun:stun1.l.google.com:19302'}];}async initialize(){// Generate local peer ID\nthis.localPeerId=this.generatePeerId();// Connect to signaling server\n// In production, this would be a secure WebSocket server\nthis.connectToSignalingServer();}generatePeerId(){return'peer-'+Math.random().toString(36).substr(2,9);}connectToSignalingServer(){// Simplified for demo - real implementation would use secure WebSocket\nconsole.log('Connecting to signaling server...');// Simulate connection\nsetTimeout(()=>{console.log('Connected to signaling server');},1000);}async connectToPeer(peerId){return new P2PConnection(peerId,this.iceServers);}}/**\n * Individual P2P Connection\n * Manages a single peer connection with data and media channels\n */class P2PConnection{constructor(peerId,iceServers){this.peerId=peerId;this.pc=null;this.dataChannel=null;this.localStream=null;this.remoteStream=null;this.isConnected=false;this.state='new';this.messageHandlers=[];this.remoteStreamHandlers=[];this.initializePeerConnection(iceServers);}initializePeerConnection(iceServers){this.pc=new RTCPeerConnection({iceServers:iceServers});// Handle connection state changes\nthis.pc.onconnectionstatechange=()=>{this.state=this.pc.connectionState;this.isConnected=this.state==='connected';console.log('Connection state:',this.state);};// Handle incoming tracks (for video/audio)\nthis.pc.ontrack=event=>{if(event.streams&&event.streams[0]){this.remoteStream=event.streams[0];this.remoteStreamHandlers.forEach(handler=>handler(this.remoteStream));}};// Create data channel for messages\nthis.dataChannel=this.pc.createDataChannel('messages',{ordered:true});this.dataChannel.onopen=()=>{console.log('Data channel opened');this.isConnected=true;};this.dataChannel.onmessage=event=>{const message=JSON.parse(event.data);this.messageHandlers.forEach(handler=>handler(message));};// Start connection process\nthis.createOffer();}async createOffer(){try{const offer=await this.pc.createOffer();await this.pc.setLocalDescription(offer);// In real implementation, send offer through signaling server\nconsole.log('Offer created and set as local description');}catch(error){console.error('Failed to create offer:',error);}}async handleAnswer(answer){try{await this.pc.setRemoteDescription(answer);console.log('Answer set as remote description');}catch(error){console.error('Failed to handle answer:',error);}}send(message){if(this.dataChannel&&this.dataChannel.readyState==='open'){this.dataChannel.send(JSON.stringify(message));return true;}return false;}onMessage(callback){this.messageHandlers.push(callback);return()=>{this.messageHandlers=this.messageHandlers.filter(h=>h!==callback);};}onRemoteStream(callback){this.remoteStreamHandlers.push(callback);// If stream already available, call immediately\nif(this.remoteStream){callback(this.remoteStream);}return()=>{this.remoteStreamHandlers=this.remoteStreamHandlers.filter(h=>h!==callback);};}async startCall(localStream){this.localStream=localStream;// Add tracks to peer connection\nlocalStream.getTracks().forEach(track=>{this.pc.addTrack(track,localStream);});// Renegotiate if needed\nif(this.pc.signalingState==='stable'){await this.createOffer();}}endCall(){// Stop all local tracks\nif(this.localStream){this.localStream.getTracks().forEach(track=>track.stop());}// Close peer connection\nif(this.pc){this.pc.close();}this.isConnected=false;this.state='closed';}toggleVideo(){if(this.localStream){const videoTrack=this.localStream.getVideoTracks()[0];if(videoTrack){videoTrack.enabled=!videoTrack.enabled;}}}toggleAudio(){if(this.localStream){const audioTrack=this.localStream.getAudioTracks()[0];if(audioTrack){audioTrack.enabled=!audioTrack.enabled;}}}}// What we're NOT implementing:\n// - Complex signaling protocols (SIP, XMPP)\n// - Multi-party video conferencing\n// - Screen recording\n// - Network quality adaptation\n// - Simulcast/SVC\n// Just simple, reliable P2P connections","map":{"version":3,"names":["P2PService","constructor","signalingServer","localPeerId","iceServers","urls","initialize","generatePeerId","connectToSignalingServer","Math","random","toString","substr","console","log","setTimeout","connectToPeer","peerId","P2PConnection","pc","dataChannel","localStream","remoteStream","isConnected","state","messageHandlers","remoteStreamHandlers","initializePeerConnection","RTCPeerConnection","onconnectionstatechange","connectionState","ontrack","event","streams","forEach","handler","createDataChannel","ordered","onopen","onmessage","message","JSON","parse","data","createOffer","offer","setLocalDescription","error","handleAnswer","answer","setRemoteDescription","send","readyState","stringify","onMessage","callback","push","filter","h","onRemoteStream","startCall","getTracks","track","addTrack","signalingState","endCall","stop","close","toggleVideo","videoTrack","getVideoTracks","enabled","toggleAudio","audioTrack","getAudioTracks"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/p2p/p2p-service.js"],"sourcesContent":["/**\n * P2P Service\n * Handles WebRTC peer-to-peer connections\n * Simple signaling through WebSocket, direct data/media channels\n */\nexport class P2PService {\n  constructor() {\n    this.signalingServer = null;\n    this.localPeerId = null;\n    this.iceServers = [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' }\n    ];\n  }\n\n  async initialize() {\n    // Generate local peer ID\n    this.localPeerId = this.generatePeerId();\n    \n    // Connect to signaling server\n    // In production, this would be a secure WebSocket server\n    this.connectToSignalingServer();\n  }\n\n  generatePeerId() {\n    return 'peer-' + Math.random().toString(36).substr(2, 9);\n  }\n\n  connectToSignalingServer() {\n    // Simplified for demo - real implementation would use secure WebSocket\n    console.log('Connecting to signaling server...');\n    \n    // Simulate connection\n    setTimeout(() => {\n      console.log('Connected to signaling server');\n    }, 1000);\n  }\n\n  async connectToPeer(peerId) {\n    return new P2PConnection(peerId, this.iceServers);\n  }\n}\n\n/**\n * Individual P2P Connection\n * Manages a single peer connection with data and media channels\n */\nclass P2PConnection {\n  constructor(peerId, iceServers) {\n    this.peerId = peerId;\n    this.pc = null;\n    this.dataChannel = null;\n    this.localStream = null;\n    this.remoteStream = null;\n    this.isConnected = false;\n    this.state = 'new';\n    this.messageHandlers = [];\n    this.remoteStreamHandlers = [];\n    \n    this.initializePeerConnection(iceServers);\n  }\n\n  initializePeerConnection(iceServers) {\n    this.pc = new RTCPeerConnection({\n      iceServers: iceServers\n    });\n\n    // Handle connection state changes\n    this.pc.onconnectionstatechange = () => {\n      this.state = this.pc.connectionState;\n      this.isConnected = this.state === 'connected';\n      console.log('Connection state:', this.state);\n    };\n\n    // Handle incoming tracks (for video/audio)\n    this.pc.ontrack = (event) => {\n      if (event.streams && event.streams[0]) {\n        this.remoteStream = event.streams[0];\n        this.remoteStreamHandlers.forEach(handler => handler(this.remoteStream));\n      }\n    };\n\n    // Create data channel for messages\n    this.dataChannel = this.pc.createDataChannel('messages', {\n      ordered: true\n    });\n\n    this.dataChannel.onopen = () => {\n      console.log('Data channel opened');\n      this.isConnected = true;\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      this.messageHandlers.forEach(handler => handler(message));\n    };\n\n    // Start connection process\n    this.createOffer();\n  }\n\n  async createOffer() {\n    try {\n      const offer = await this.pc.createOffer();\n      await this.pc.setLocalDescription(offer);\n      \n      // In real implementation, send offer through signaling server\n      console.log('Offer created and set as local description');\n    } catch (error) {\n      console.error('Failed to create offer:', error);\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.pc.setRemoteDescription(answer);\n      console.log('Answer set as remote description');\n    } catch (error) {\n      console.error('Failed to handle answer:', error);\n    }\n  }\n\n  send(message) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }\n\n  onMessage(callback) {\n    this.messageHandlers.push(callback);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== callback);\n    };\n  }\n\n  onRemoteStream(callback) {\n    this.remoteStreamHandlers.push(callback);\n    // If stream already available, call immediately\n    if (this.remoteStream) {\n      callback(this.remoteStream);\n    }\n    return () => {\n      this.remoteStreamHandlers = this.remoteStreamHandlers.filter(h => h !== callback);\n    };\n  }\n\n  async startCall(localStream) {\n    this.localStream = localStream;\n    \n    // Add tracks to peer connection\n    localStream.getTracks().forEach(track => {\n      this.pc.addTrack(track, localStream);\n    });\n\n    // Renegotiate if needed\n    if (this.pc.signalingState === 'stable') {\n      await this.createOffer();\n    }\n  }\n\n  endCall() {\n    // Stop all local tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n    }\n    \n    // Close peer connection\n    if (this.pc) {\n      this.pc.close();\n    }\n    \n    this.isConnected = false;\n    this.state = 'closed';\n  }\n\n  toggleVideo() {\n    if (this.localStream) {\n      const videoTrack = this.localStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n      }\n    }\n  }\n\n  toggleAudio() {\n    if (this.localStream) {\n      const audioTrack = this.localStream.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n      }\n    }\n  }\n}\n\n// What we're NOT implementing:\n// - Complex signaling protocols (SIP, XMPP)\n// - Multi-party video conferencing\n// - Screen recording\n// - Network quality adaptation\n// - Simulcast/SVC\n// Just simple, reliable P2P connections"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}