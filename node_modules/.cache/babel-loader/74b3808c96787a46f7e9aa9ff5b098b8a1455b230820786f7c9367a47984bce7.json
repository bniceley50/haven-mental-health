{"ast":null,"code":"import { argon2id } from '@noble/hashes/argon2';\nimport { randomBytes } from '@noble/hashes/utils';\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n\n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n\n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n\n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n  async createDemoAccount() {\n    // Create a demo therapist account\n    const demoEmail = 'demo@haven.health';\n    const demoPassword = 'demo1234';\n    try {\n      await this.register(demoEmail, demoPassword, 'Demo Therapist');\n      console.log('Demo account created successfully');\n    } catch (error) {\n      // Account might already exist\n      console.log('Demo account ready');\n    }\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3,\n      // iterations\n      m: 64 * 1024,\n      // memory in KB\n      p: 1 // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true // Only therapists in this app\n    });\n    return {\n      success: true,\n      email\n    };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1\n    });\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000) // 8 hours\n    };\n    this.sessions.set(sessionId, session);\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["argon2id","randomBytes","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","demoPassword","register","console","log","error","email","password","name","length","Error","has","salt","hash","t","m","p","set","id","toString","split","Buffer","concat","createdAt","Date","isTherapist","success","login","attempts","get","user","hashBuffer","from","slice","storedHash","inputHash","valid","compare","delete","sessionId","session","userId","expiresAt","now","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["import { argon2id } from '@noble/hashes/argon2';\nimport { randomBytes } from '@noble/hashes/utils';\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  async createDemoAccount() {\n    // Create a demo therapist account\n    const demoEmail = 'demo@haven.health';\n    const demoPassword = 'demo1234';\n    \n    try {\n      await this.register(demoEmail, demoPassword, 'Demo Therapist');\n      console.log('Demo account created successfully');\n    } catch (error) {\n      // Account might already exist\n      console.log('Demo account ready');\n    }\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3, // iterations\n      m: 64 * 1024, // memory in KB\n      p: 1, // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    \n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1,\n    });\n\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}