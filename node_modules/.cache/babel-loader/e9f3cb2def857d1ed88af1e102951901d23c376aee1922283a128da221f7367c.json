{"ast":null,"code":"import { randomBytes } from '@noble/hashes/utils';\n\n/**\n * Encryption Service\n * Handles all encryption/decryption operations for PHI data\n * Uses Web Crypto API with AES-256-GCM\n */\nexport class EncryptionService {\n  constructor() {\n    this.algorithm = 'AES-GCM';\n    this.keyLength = 256;\n    this.ivLength = 12; // 96 bits for GCM\n    this.tagLength = 128; // 128-bit auth tag\n    this.masterKey = null;\n  }\n  async initialize() {\n    // In production, this would retrieve/generate keys securely\n    // For now, we'll generate a new key per session\n    this.masterKey = await this.generateKey();\n\n    // Store key in session storage (not ideal for production)\n    // Real implementation would use secure key management\n    const exportedKey = await window.crypto.subtle.exportKey('raw', this.masterKey);\n    sessionStorage.setItem('haven-temp-key', this.arrayBufferToBase64(exportedKey));\n  }\n  async generateKey() {\n    return window.crypto.subtle.generateKey({\n      name: this.algorithm,\n      length: this.keyLength\n    }, true,\n    // extractable\n    ['encrypt', 'decrypt']);\n  }\n  async encrypt(data) {\n    if (!this.masterKey) {\n      throw new Error('Encryption key not initialized');\n    }\n\n    // Convert data to JSON string\n    const plaintext = JSON.stringify(data);\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(plaintext);\n\n    // Generate random IV\n    const iv = randomBytes(this.ivLength);\n\n    // Encrypt\n    const ciphertext = await window.crypto.subtle.encrypt({\n      name: this.algorithm,\n      iv: iv,\n      tagLength: this.tagLength\n    }, this.masterKey, encodedData);\n\n    // Combine IV and ciphertext\n    const combined = new Uint8Array(iv.length + ciphertext.byteLength);\n    combined.set(iv, 0);\n    combined.set(new Uint8Array(ciphertext), iv.length);\n\n    // Return base64 encoded\n    return {\n      data: this.arrayBufferToBase64(combined),\n      algorithm: this.algorithm,\n      timestamp: Date.now()\n    };\n  }\n  async decrypt(encryptedData) {\n    if (!this.masterKey) {\n      throw new Error('Encryption key not initialized');\n    }\n\n    // Decode from base64\n    const combined = this.base64ToArrayBuffer(encryptedData.data);\n\n    // Extract IV and ciphertext\n    const iv = combined.slice(0, this.ivLength);\n    const ciphertext = combined.slice(this.ivLength);\n\n    // Decrypt\n    const decrypted = await window.crypto.subtle.decrypt({\n      name: this.algorithm,\n      iv: iv,\n      tagLength: this.tagLength\n    }, this.masterKey, ciphertext);\n\n    // Decode and parse JSON\n    const decoder = new TextDecoder();\n    const plaintext = decoder.decode(decrypted);\n    return JSON.parse(plaintext);\n  }\n\n  // Utility functions\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n  }\n\n  // Generate encryption metadata for audit logs\n  getEncryptionMetadata() {\n    return {\n      algorithm: this.algorithm,\n      keyLength: this.keyLength,\n      ivLength: this.ivLength,\n      tagLength: this.tagLength,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// What we're NOT implementing:\n// - Key rotation (can add later)\n// - Hardware security module (HSM) integration\n// - Multi-tenant key management\n// - Encrypted search capabilities\n// - Homomorphic encryption\n// Just solid, standard AES-256-GCM encryption","map":{"version":3,"names":["randomBytes","EncryptionService","constructor","algorithm","keyLength","ivLength","tagLength","masterKey","initialize","generateKey","exportedKey","window","crypto","subtle","exportKey","sessionStorage","setItem","arrayBufferToBase64","name","length","encrypt","data","Error","plaintext","JSON","stringify","encoder","TextEncoder","encodedData","encode","iv","ciphertext","combined","Uint8Array","byteLength","set","timestamp","Date","now","decrypt","encryptedData","base64ToArrayBuffer","slice","decrypted","decoder","TextDecoder","decode","parse","buffer","bytes","binary","i","String","fromCharCode","btoa","base64","atob","charCodeAt","getEncryptionMetadata","toISOString"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/encryption/encryption-service.js"],"sourcesContent":["import { randomBytes } from '@noble/hashes/utils';\n\n/**\n * Encryption Service\n * Handles all encryption/decryption operations for PHI data\n * Uses Web Crypto API with AES-256-GCM\n */\nexport class EncryptionService {\n  constructor() {\n    this.algorithm = 'AES-GCM';\n    this.keyLength = 256;\n    this.ivLength = 12; // 96 bits for GCM\n    this.tagLength = 128; // 128-bit auth tag\n    this.masterKey = null;\n  }\n\n  async initialize() {\n    // In production, this would retrieve/generate keys securely\n    // For now, we'll generate a new key per session\n    this.masterKey = await this.generateKey();\n    \n    // Store key in session storage (not ideal for production)\n    // Real implementation would use secure key management\n    const exportedKey = await window.crypto.subtle.exportKey('raw', this.masterKey);\n    sessionStorage.setItem('haven-temp-key', this.arrayBufferToBase64(exportedKey));\n  }\n\n  async generateKey() {\n    return window.crypto.subtle.generateKey(\n      {\n        name: this.algorithm,\n        length: this.keyLength\n      },\n      true, // extractable\n      ['encrypt', 'decrypt']\n    );\n  }\n\n  async encrypt(data) {\n    if (!this.masterKey) {\n      throw new Error('Encryption key not initialized');\n    }\n\n    // Convert data to JSON string\n    const plaintext = JSON.stringify(data);\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(plaintext);\n\n    // Generate random IV\n    const iv = randomBytes(this.ivLength);\n\n    // Encrypt\n    const ciphertext = await window.crypto.subtle.encrypt(\n      {\n        name: this.algorithm,\n        iv: iv,\n        tagLength: this.tagLength\n      },\n      this.masterKey,\n      encodedData\n    );\n\n    // Combine IV and ciphertext\n    const combined = new Uint8Array(iv.length + ciphertext.byteLength);\n    combined.set(iv, 0);\n    combined.set(new Uint8Array(ciphertext), iv.length);\n\n    // Return base64 encoded\n    return {\n      data: this.arrayBufferToBase64(combined),\n      algorithm: this.algorithm,\n      timestamp: Date.now()\n    };\n  }\n\n  async decrypt(encryptedData) {\n    if (!this.masterKey) {\n      throw new Error('Encryption key not initialized');\n    }\n\n    // Decode from base64\n    const combined = this.base64ToArrayBuffer(encryptedData.data);\n    \n    // Extract IV and ciphertext\n    const iv = combined.slice(0, this.ivLength);\n    const ciphertext = combined.slice(this.ivLength);\n\n    // Decrypt\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: this.algorithm,\n        iv: iv,\n        tagLength: this.tagLength\n      },\n      this.masterKey,\n      ciphertext\n    );\n\n    // Decode and parse JSON\n    const decoder = new TextDecoder();\n    const plaintext = decoder.decode(decrypted);\n    return JSON.parse(plaintext);\n  }\n\n  // Utility functions\n  arrayBufferToBase64(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let binary = '';\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n\n  base64ToArrayBuffer(base64) {\n    const binary = atob(base64);\n    const bytes = new Uint8Array(binary.length);\n    for (let i = 0; i < binary.length; i++) {\n      bytes[i] = binary.charCodeAt(i);\n    }\n    return bytes;\n  }\n\n  // Generate encryption metadata for audit logs\n  getEncryptionMetadata() {\n    return {\n      algorithm: this.algorithm,\n      keyLength: this.keyLength,\n      ivLength: this.ivLength,\n      tagLength: this.tagLength,\n      timestamp: new Date().toISOString()\n    };\n  }\n}\n\n// What we're NOT implementing:\n// - Key rotation (can add later)\n// - Hardware security module (HSM) integration\n// - Multi-tenant key management\n// - Encrypted search capabilities\n// - Homomorphic encryption\n// Just solid, standard AES-256-GCM encryption"],"mappings":"AAAA,SAASA,WAAW,QAAQ,qBAAqB;;AAEjD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,CAAC;EAC7BC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,SAAS,GAAG,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAG,GAAG;IACpB,IAAI,CAACC,QAAQ,GAAG,EAAE,CAAC,CAAC;IACpB,IAAI,CAACC,SAAS,GAAG,GAAG,CAAC,CAAC;IACtB,IAAI,CAACC,SAAS,GAAG,IAAI;EACvB;EAEA,MAAMC,UAAUA,CAAA,EAAG;IACjB;IACA;IACA,IAAI,CAACD,SAAS,GAAG,MAAM,IAAI,CAACE,WAAW,CAAC,CAAC;;IAEzC;IACA;IACA,MAAMC,WAAW,GAAG,MAAMC,MAAM,CAACC,MAAM,CAACC,MAAM,CAACC,SAAS,CAAC,KAAK,EAAE,IAAI,CAACP,SAAS,CAAC;IAC/EQ,cAAc,CAACC,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAACC,mBAAmB,CAACP,WAAW,CAAC,CAAC;EACjF;EAEA,MAAMD,WAAWA,CAAA,EAAG;IAClB,OAAOE,MAAM,CAACC,MAAM,CAACC,MAAM,CAACJ,WAAW,CACrC;MACES,IAAI,EAAE,IAAI,CAACf,SAAS;MACpBgB,MAAM,EAAE,IAAI,CAACf;IACf,CAAC,EACD,IAAI;IAAE;IACN,CAAC,SAAS,EAAE,SAAS,CACvB,CAAC;EACH;EAEA,MAAMgB,OAAOA,CAACC,IAAI,EAAE;IAClB,IAAI,CAAC,IAAI,CAACd,SAAS,EAAE;MACnB,MAAM,IAAIe,KAAK,CAAC,gCAAgC,CAAC;IACnD;;IAEA;IACA,MAAMC,SAAS,GAAGC,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;IACtC,MAAMK,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;IACjC,MAAMC,WAAW,GAAGF,OAAO,CAACG,MAAM,CAACN,SAAS,CAAC;;IAE7C;IACA,MAAMO,EAAE,GAAG9B,WAAW,CAAC,IAAI,CAACK,QAAQ,CAAC;;IAErC;IACA,MAAM0B,UAAU,GAAG,MAAMpB,MAAM,CAACC,MAAM,CAACC,MAAM,CAACO,OAAO,CACnD;MACEF,IAAI,EAAE,IAAI,CAACf,SAAS;MACpB2B,EAAE,EAAEA,EAAE;MACNxB,SAAS,EAAE,IAAI,CAACA;IAClB,CAAC,EACD,IAAI,CAACC,SAAS,EACdqB,WACF,CAAC;;IAED;IACA,MAAMI,QAAQ,GAAG,IAAIC,UAAU,CAACH,EAAE,CAACX,MAAM,GAAGY,UAAU,CAACG,UAAU,CAAC;IAClEF,QAAQ,CAACG,GAAG,CAACL,EAAE,EAAE,CAAC,CAAC;IACnBE,QAAQ,CAACG,GAAG,CAAC,IAAIF,UAAU,CAACF,UAAU,CAAC,EAAED,EAAE,CAACX,MAAM,CAAC;;IAEnD;IACA,OAAO;MACLE,IAAI,EAAE,IAAI,CAACJ,mBAAmB,CAACe,QAAQ,CAAC;MACxC7B,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBiC,SAAS,EAAEC,IAAI,CAACC,GAAG,CAAC;IACtB,CAAC;EACH;EAEA,MAAMC,OAAOA,CAACC,aAAa,EAAE;IAC3B,IAAI,CAAC,IAAI,CAACjC,SAAS,EAAE;MACnB,MAAM,IAAIe,KAAK,CAAC,gCAAgC,CAAC;IACnD;;IAEA;IACA,MAAMU,QAAQ,GAAG,IAAI,CAACS,mBAAmB,CAACD,aAAa,CAACnB,IAAI,CAAC;;IAE7D;IACA,MAAMS,EAAE,GAAGE,QAAQ,CAACU,KAAK,CAAC,CAAC,EAAE,IAAI,CAACrC,QAAQ,CAAC;IAC3C,MAAM0B,UAAU,GAAGC,QAAQ,CAACU,KAAK,CAAC,IAAI,CAACrC,QAAQ,CAAC;;IAEhD;IACA,MAAMsC,SAAS,GAAG,MAAMhC,MAAM,CAACC,MAAM,CAACC,MAAM,CAAC0B,OAAO,CAClD;MACErB,IAAI,EAAE,IAAI,CAACf,SAAS;MACpB2B,EAAE,EAAEA,EAAE;MACNxB,SAAS,EAAE,IAAI,CAACA;IAClB,CAAC,EACD,IAAI,CAACC,SAAS,EACdwB,UACF,CAAC;;IAED;IACA,MAAMa,OAAO,GAAG,IAAIC,WAAW,CAAC,CAAC;IACjC,MAAMtB,SAAS,GAAGqB,OAAO,CAACE,MAAM,CAACH,SAAS,CAAC;IAC3C,OAAOnB,IAAI,CAACuB,KAAK,CAACxB,SAAS,CAAC;EAC9B;;EAEA;EACAN,mBAAmBA,CAAC+B,MAAM,EAAE;IAC1B,MAAMC,KAAK,GAAG,IAAIhB,UAAU,CAACe,MAAM,CAAC;IACpC,IAAIE,MAAM,GAAG,EAAE;IACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACf,UAAU,EAAEiB,CAAC,EAAE,EAAE;MACzCD,MAAM,IAAIE,MAAM,CAACC,YAAY,CAACJ,KAAK,CAACE,CAAC,CAAC,CAAC;IACzC;IACA,OAAOG,IAAI,CAACJ,MAAM,CAAC;EACrB;EAEAT,mBAAmBA,CAACc,MAAM,EAAE;IAC1B,MAAML,MAAM,GAAGM,IAAI,CAACD,MAAM,CAAC;IAC3B,MAAMN,KAAK,GAAG,IAAIhB,UAAU,CAACiB,MAAM,CAAC/B,MAAM,CAAC;IAC3C,KAAK,IAAIgC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAAC/B,MAAM,EAAEgC,CAAC,EAAE,EAAE;MACtCF,KAAK,CAACE,CAAC,CAAC,GAAGD,MAAM,CAACO,UAAU,CAACN,CAAC,CAAC;IACjC;IACA,OAAOF,KAAK;EACd;;EAEA;EACAS,qBAAqBA,CAAA,EAAG;IACtB,OAAO;MACLvD,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBC,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBC,SAAS,EAAE,IAAI,CAACA,SAAS;MACzB8B,SAAS,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACsB,WAAW,CAAC;IACpC,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}