{"ast":null,"code":"// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = password => {\n  // Simple hash for demo - NOT for production\n  // Using btoa for browser compatibility\n  return btoa(password);\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n\n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n\n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n\n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Simple hash for demo\n    const hashedPassword = simpleHash(password);\n\n    // Store user\n    this.users.set(email, {\n      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n      email,\n      name: name || email.split('@')[0],\n      hash: hashedPassword,\n      createdAt: new Date(),\n      isTherapist: true // Only therapists in this app\n    });\n    return {\n      success: true,\n      email\n    };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password (simple for demo)\n    const inputHash = simpleHash(password);\n    const valid = inputHash === user.hash;\n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000) // 8 hours\n    };\n    this.sessions.set(sessionId, session);\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["simpleHash","password","btoa","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","set","id","email","name","hash","createdAt","Date","isTherapist","console","log","register","length","Error","has","hashedPassword","crypto","randomUUID","now","toString","split","success","login","attempts","get","user","inputHash","valid","delete","sessionId","session","userId","expiresAt","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = (password) => {\n  // Simple hash for demo - NOT for production\n  // Using btoa for browser compatibility\n  return btoa(password);\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Simple hash for demo\n    const hashedPassword = simpleHash(password);\n\n    // Store user\n    this.users.set(email, {\n      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n      email,\n      name: name || email.split('@')[0],\n      hash: hashedPassword,\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password (simple for demo)\n    const inputHash = simpleHash(password);\n    const valid = inputHash === user.hash;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}