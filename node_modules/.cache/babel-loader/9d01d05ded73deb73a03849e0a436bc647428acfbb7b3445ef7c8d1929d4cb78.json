{"ast":null,"code":"// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = password => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\nconst randomBytes = length => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n\n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n\n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n\n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Simple hash for demo\n    const hashedPassword = simpleHash(password);\n\n    // Store user\n    this.users.set(email, {\n      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n      email,\n      name: name || email.split('@')[0],\n      hash: hashedPassword,\n      createdAt: new Date(),\n      isTherapist: true // Only therapists in this app\n    });\n    return {\n      success: true,\n      email\n    };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password (simple for demo)\n    const inputHash = simpleHash(password);\n    const valid = inputHash === user.hash;\n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000) // 8 hours\n    };\n    this.sessions.set(sessionId, session);\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["simpleHash","password","Buffer","from","toString","randomBytes","length","array","Uint8Array","crypto","getRandomValues","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","set","id","email","name","hash","createdAt","Date","isTherapist","console","log","register","Error","has","hashedPassword","randomUUID","now","split","success","login","attempts","get","user","inputHash","valid","delete","sessionId","session","userId","expiresAt","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = (password) => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\n\nconst randomBytes = (length) => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Simple hash for demo\n    const hashedPassword = simpleHash(password);\n\n    // Store user\n    this.users.set(email, {\n      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n      email,\n      name: name || email.split('@')[0],\n      hash: hashedPassword,\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password (simple for demo)\n    const inputHash = simpleHash(password);\n    const valid = inputHash === user.hash;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}