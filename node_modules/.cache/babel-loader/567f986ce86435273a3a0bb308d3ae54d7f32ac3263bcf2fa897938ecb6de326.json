{"ast":null,"code":"import React,{createContext,useContext,useState,useEffect}from'react';import{P2PService}from'./p2p-service';import{jsx as _jsx}from\"react/jsx-runtime\";const P2PContext=/*#__PURE__*/createContext();/**\n * P2P Provider\n * Manages peer-to-peer connections for secure messaging and video\n * Uses WebRTC for direct therapist-patient communication\n */export function P2PProvider(_ref){let{children}=_ref;const[p2pService,setP2PService]=useState(null);const[connections,setConnections]=useState(new Map());const[isReady,setIsReady]=useState(false);useEffect(()=>{initializeP2P();},[]);const initializeP2P=async()=>{try{const service=new P2PService();await service.initialize();setP2PService(service);setIsReady(true);}catch(error){console.error('Failed to initialize P2P:',error);}};const connectToPeer=async peerId=>{if(!p2pService){throw new Error('P2P service not initialized');}// Check if already connected\nif(connections.has(peerId)){return connections.get(peerId);}// Create new connection\nconst connection=await p2pService.connectToPeer(peerId);setConnections(new Map(connections.set(peerId,connection)));return connection;};const sendMessage=async(peerId,message)=>{const connection=await connectToPeer(peerId);return connection.send(message);};const onMessage=(peerId,callback)=>{const connection=connections.get(peerId);if(!connection){console.warn('No connection found for peer:',peerId);return()=>{};}return connection.onMessage(callback);};const startCall=async(peerId,localStream)=>{const connection=await connectToPeer(peerId);return connection.startCall(localStream);};const endCall=peerId=>{const connection=connections.get(peerId);if(connection){connection.endCall();}};const value={isReady,connectToPeer,sendMessage,onMessage,startCall,endCall,connections};return/*#__PURE__*/_jsx(P2PContext.Provider,{value:value,children:children});}export function useP2P(peerId){const context=useContext(P2PContext);if(!context){throw new Error('useP2P must be used within P2PProvider');}const{connections,sendMessage,onMessage,startCall,endCall,connectToPeer}=context;const connection=connections.get(peerId);return{isConnected:(connection===null||connection===void 0?void 0:connection.isConnected)||false,connectionState:(connection===null||connection===void 0?void 0:connection.state)||'disconnected',sendMessage:message=>sendMessage(peerId,message),onMessage:callback=>onMessage(peerId,callback),startCall:stream=>startCall(peerId,stream),endCall:()=>endCall(peerId),connect:()=>connectToPeer(peerId),onRemoteStream:callback=>{if(connection){return connection.onRemoteStream(callback);}return()=>{};},toggleVideo:()=>connection===null||connection===void 0?void 0:connection.toggleVideo(),toggleAudio:()=>connection===null||connection===void 0?void 0:connection.toggleAudio()};}","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","P2PService","jsx","_jsx","P2PContext","P2PProvider","_ref","children","p2pService","setP2PService","connections","setConnections","Map","isReady","setIsReady","initializeP2P","service","initialize","error","console","connectToPeer","peerId","Error","has","get","connection","set","sendMessage","message","send","onMessage","callback","warn","startCall","localStream","endCall","value","Provider","useP2P","context","isConnected","connectionState","state","stream","connect","onRemoteStream","toggleVideo","toggleAudio"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/p2p/p2p-provider.jsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { P2PService } from './p2p-service';\n\nconst P2PContext = createContext();\n\n/**\n * P2P Provider\n * Manages peer-to-peer connections for secure messaging and video\n * Uses WebRTC for direct therapist-patient communication\n */\nexport function P2PProvider({ children }) {\n  const [p2pService, setP2PService] = useState(null);\n  const [connections, setConnections] = useState(new Map());\n  const [isReady, setIsReady] = useState(false);\n\n  useEffect(() => {\n    initializeP2P();\n  }, []);\n\n  const initializeP2P = async () => {\n    try {\n      const service = new P2PService();\n      await service.initialize();\n      setP2PService(service);\n      setIsReady(true);\n    } catch (error) {\n      console.error('Failed to initialize P2P:', error);\n    }\n  };\n\n  const connectToPeer = async (peerId) => {\n    if (!p2pService) {\n      throw new Error('P2P service not initialized');\n    }\n\n    // Check if already connected\n    if (connections.has(peerId)) {\n      return connections.get(peerId);\n    }\n\n    // Create new connection\n    const connection = await p2pService.connectToPeer(peerId);\n    setConnections(new Map(connections.set(peerId, connection)));\n    \n    return connection;\n  };\n\n  const sendMessage = async (peerId, message) => {\n    const connection = await connectToPeer(peerId);\n    return connection.send(message);\n  };\n\n  const onMessage = (peerId, callback) => {\n    const connection = connections.get(peerId);\n    if (!connection) {\n      console.warn('No connection found for peer:', peerId);\n      return () => {};\n    }\n\n    return connection.onMessage(callback);\n  };\n\n  const startCall = async (peerId, localStream) => {\n    const connection = await connectToPeer(peerId);\n    return connection.startCall(localStream);\n  };\n\n  const endCall = (peerId) => {\n    const connection = connections.get(peerId);\n    if (connection) {\n      connection.endCall();\n    }\n  };\n\n  const value = {\n    isReady,\n    connectToPeer,\n    sendMessage,\n    onMessage,\n    startCall,\n    endCall,\n    connections\n  };\n\n  return (\n    <P2PContext.Provider value={value}>\n      {children}\n    </P2PContext.Provider>\n  );\n}\n\nexport function useP2P(peerId) {\n  const context = useContext(P2PContext);\n  if (!context) {\n    throw new Error('useP2P must be used within P2PProvider');\n  }\n\n  const { connections, sendMessage, onMessage, startCall, endCall, connectToPeer } = context;\n  const connection = connections.get(peerId);\n\n  return {\n    isConnected: connection?.isConnected || false,\n    connectionState: connection?.state || 'disconnected',\n    sendMessage: (message) => sendMessage(peerId, message),\n    onMessage: (callback) => onMessage(peerId, callback),\n    startCall: (stream) => startCall(peerId, stream),\n    endCall: () => endCall(peerId),\n    connect: () => connectToPeer(peerId),\n    onRemoteStream: (callback) => {\n      if (connection) {\n        return connection.onRemoteStream(callback);\n      }\n      return () => {};\n    },\n    toggleVideo: () => connection?.toggleVideo(),\n    toggleAudio: () => connection?.toggleAudio()\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}