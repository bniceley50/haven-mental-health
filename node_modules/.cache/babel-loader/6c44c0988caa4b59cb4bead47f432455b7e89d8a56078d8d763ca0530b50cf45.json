{"ast":null,"code":"/**\n * P2P Service\n * Handles WebRTC peer-to-peer connections\n * Simple signaling through WebSocket, direct data/media channels\n */\nexport class P2PService {\n  constructor() {\n    this.signalingServer = null;\n    this.localPeerId = null;\n    this.iceServers = [{\n      urls: 'stun:stun.l.google.com:19302'\n    }, {\n      urls: 'stun:stun1.l.google.com:19302'\n    }];\n  }\n  async initialize() {\n    // Generate local peer ID\n    this.localPeerId = this.generatePeerId();\n\n    // Connect to signaling server\n    // In production, this would be a secure WebSocket server\n    this.connectToSignalingServer();\n  }\n  generatePeerId() {\n    return 'peer-' + Math.random().toString(36).substr(2, 9);\n  }\n  connectToSignalingServer() {\n    // Simplified for demo - real implementation would use secure WebSocket\n    console.log('Connecting to signaling server...');\n\n    // Simulate connection\n    setTimeout(() => {\n      console.log('Connected to signaling server');\n    }, 1000);\n  }\n  async connectToPeer(peerId) {\n    return new P2PConnection(peerId, this.iceServers);\n  }\n}\n\n/**\n * Individual P2P Connection\n * Manages a single peer connection with data and media channels\n */\nclass P2PConnection {\n  constructor(peerId, iceServers) {\n    this.peerId = peerId;\n    this.pc = null;\n    this.dataChannel = null;\n    this.localStream = null;\n    this.remoteStream = null;\n    this.isConnected = false;\n    this.state = 'new';\n    this.messageHandlers = [];\n    this.remoteStreamHandlers = [];\n    this.initializePeerConnection(iceServers);\n  }\n  initializePeerConnection(iceServers) {\n    this.pc = new RTCPeerConnection({\n      iceServers: iceServers\n    });\n\n    // Handle connection state changes\n    this.pc.onconnectionstatechange = () => {\n      this.state = this.pc.connectionState;\n      this.isConnected = this.state === 'connected';\n      console.log('Connection state:', this.state);\n    };\n\n    // Handle incoming tracks (for video/audio)\n    this.pc.ontrack = event => {\n      if (event.streams && event.streams[0]) {\n        this.remoteStream = event.streams[0];\n        this.remoteStreamHandlers.forEach(handler => handler(this.remoteStream));\n      }\n    };\n\n    // Create data channel for messages\n    this.dataChannel = this.pc.createDataChannel('messages', {\n      ordered: true\n    });\n    this.dataChannel.onopen = () => {\n      console.log('Data channel opened');\n      this.isConnected = true;\n    };\n    this.dataChannel.onmessage = event => {\n      const message = JSON.parse(event.data);\n      this.messageHandlers.forEach(handler => handler(message));\n    };\n\n    // Start connection process\n    this.createOffer();\n  }\n  async createOffer() {\n    try {\n      const offer = await this.pc.createOffer();\n      await this.pc.setLocalDescription(offer);\n\n      // In real implementation, send offer through signaling server\n      console.log('Offer created and set as local description');\n    } catch (error) {\n      console.error('Failed to create offer:', error);\n    }\n  }\n  async handleAnswer(answer) {\n    try {\n      await this.pc.setRemoteDescription(answer);\n      console.log('Answer set as remote description');\n    } catch (error) {\n      console.error('Failed to handle answer:', error);\n    }\n  }\n  send(message) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }\n  onMessage(callback) {\n    this.messageHandlers.push(callback);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== callback);\n    };\n  }\n  onRemoteStream(callback) {\n    this.remoteStreamHandlers.push(callback);\n    // If stream already available, call immediately\n    if (this.remoteStream) {\n      callback(this.remoteStream);\n    }\n    return () => {\n      this.remoteStreamHandlers = this.remoteStreamHandlers.filter(h => h !== callback);\n    };\n  }\n  async startCall(localStream) {\n    this.localStream = localStream;\n\n    // Add tracks to peer connection\n    localStream.getTracks().forEach(track => {\n      this.pc.addTrack(track, localStream);\n    });\n\n    // Renegotiate if needed\n    if (this.pc.signalingState === 'stable') {\n      await this.createOffer();\n    }\n  }\n  endCall() {\n    // Stop all local tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n    }\n\n    // Close peer connection\n    if (this.pc) {\n      this.pc.close();\n    }\n    this.isConnected = false;\n    this.state = 'closed';\n  }\n  toggleVideo() {\n    if (this.localStream) {\n      const videoTrack = this.localStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n      }\n    }\n  }\n  toggleAudio() {\n    if (this.localStream) {\n      const audioTrack = this.localStream.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n      }\n    }\n  }\n}\n\n// What we're NOT implementing:\n// - Complex signaling protocols (SIP, XMPP)\n// - Multi-party video conferencing\n// - Screen recording\n// - Network quality adaptation\n// - Simulcast/SVC\n// Just simple, reliable P2P connections","map":{"version":3,"names":["P2PService","constructor","signalingServer","localPeerId","iceServers","urls","initialize","generatePeerId","connectToSignalingServer","Math","random","toString","substr","console","log","setTimeout","connectToPeer","peerId","P2PConnection","pc","dataChannel","localStream","remoteStream","isConnected","state","messageHandlers","remoteStreamHandlers","initializePeerConnection","RTCPeerConnection","onconnectionstatechange","connectionState","ontrack","event","streams","forEach","handler","createDataChannel","ordered","onopen","onmessage","message","JSON","parse","data","createOffer","offer","setLocalDescription","error","handleAnswer","answer","setRemoteDescription","send","readyState","stringify","onMessage","callback","push","filter","h","onRemoteStream","startCall","getTracks","track","addTrack","signalingState","endCall","stop","close","toggleVideo","videoTrack","getVideoTracks","enabled","toggleAudio","audioTrack","getAudioTracks"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/p2p/p2p-service.js"],"sourcesContent":["/**\n * P2P Service\n * Handles WebRTC peer-to-peer connections\n * Simple signaling through WebSocket, direct data/media channels\n */\nexport class P2PService {\n  constructor() {\n    this.signalingServer = null;\n    this.localPeerId = null;\n    this.iceServers = [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' }\n    ];\n  }\n\n  async initialize() {\n    // Generate local peer ID\n    this.localPeerId = this.generatePeerId();\n    \n    // Connect to signaling server\n    // In production, this would be a secure WebSocket server\n    this.connectToSignalingServer();\n  }\n\n  generatePeerId() {\n    return 'peer-' + Math.random().toString(36).substr(2, 9);\n  }\n\n  connectToSignalingServer() {\n    // Simplified for demo - real implementation would use secure WebSocket\n    console.log('Connecting to signaling server...');\n    \n    // Simulate connection\n    setTimeout(() => {\n      console.log('Connected to signaling server');\n    }, 1000);\n  }\n\n  async connectToPeer(peerId) {\n    return new P2PConnection(peerId, this.iceServers);\n  }\n}\n\n/**\n * Individual P2P Connection\n * Manages a single peer connection with data and media channels\n */\nclass P2PConnection {\n  constructor(peerId, iceServers) {\n    this.peerId = peerId;\n    this.pc = null;\n    this.dataChannel = null;\n    this.localStream = null;\n    this.remoteStream = null;\n    this.isConnected = false;\n    this.state = 'new';\n    this.messageHandlers = [];\n    this.remoteStreamHandlers = [];\n    \n    this.initializePeerConnection(iceServers);\n  }\n\n  initializePeerConnection(iceServers) {\n    this.pc = new RTCPeerConnection({\n      iceServers: iceServers\n    });\n\n    // Handle connection state changes\n    this.pc.onconnectionstatechange = () => {\n      this.state = this.pc.connectionState;\n      this.isConnected = this.state === 'connected';\n      console.log('Connection state:', this.state);\n    };\n\n    // Handle incoming tracks (for video/audio)\n    this.pc.ontrack = (event) => {\n      if (event.streams && event.streams[0]) {\n        this.remoteStream = event.streams[0];\n        this.remoteStreamHandlers.forEach(handler => handler(this.remoteStream));\n      }\n    };\n\n    // Create data channel for messages\n    this.dataChannel = this.pc.createDataChannel('messages', {\n      ordered: true\n    });\n\n    this.dataChannel.onopen = () => {\n      console.log('Data channel opened');\n      this.isConnected = true;\n    };\n\n    this.dataChannel.onmessage = (event) => {\n      const message = JSON.parse(event.data);\n      this.messageHandlers.forEach(handler => handler(message));\n    };\n\n    // Start connection process\n    this.createOffer();\n  }\n\n  async createOffer() {\n    try {\n      const offer = await this.pc.createOffer();\n      await this.pc.setLocalDescription(offer);\n      \n      // In real implementation, send offer through signaling server\n      console.log('Offer created and set as local description');\n    } catch (error) {\n      console.error('Failed to create offer:', error);\n    }\n  }\n\n  async handleAnswer(answer) {\n    try {\n      await this.pc.setRemoteDescription(answer);\n      console.log('Answer set as remote description');\n    } catch (error) {\n      console.error('Failed to handle answer:', error);\n    }\n  }\n\n  send(message) {\n    if (this.dataChannel && this.dataChannel.readyState === 'open') {\n      this.dataChannel.send(JSON.stringify(message));\n      return true;\n    }\n    return false;\n  }\n\n  onMessage(callback) {\n    this.messageHandlers.push(callback);\n    return () => {\n      this.messageHandlers = this.messageHandlers.filter(h => h !== callback);\n    };\n  }\n\n  onRemoteStream(callback) {\n    this.remoteStreamHandlers.push(callback);\n    // If stream already available, call immediately\n    if (this.remoteStream) {\n      callback(this.remoteStream);\n    }\n    return () => {\n      this.remoteStreamHandlers = this.remoteStreamHandlers.filter(h => h !== callback);\n    };\n  }\n\n  async startCall(localStream) {\n    this.localStream = localStream;\n    \n    // Add tracks to peer connection\n    localStream.getTracks().forEach(track => {\n      this.pc.addTrack(track, localStream);\n    });\n\n    // Renegotiate if needed\n    if (this.pc.signalingState === 'stable') {\n      await this.createOffer();\n    }\n  }\n\n  endCall() {\n    // Stop all local tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n    }\n    \n    // Close peer connection\n    if (this.pc) {\n      this.pc.close();\n    }\n    \n    this.isConnected = false;\n    this.state = 'closed';\n  }\n\n  toggleVideo() {\n    if (this.localStream) {\n      const videoTrack = this.localStream.getVideoTracks()[0];\n      if (videoTrack) {\n        videoTrack.enabled = !videoTrack.enabled;\n      }\n    }\n  }\n\n  toggleAudio() {\n    if (this.localStream) {\n      const audioTrack = this.localStream.getAudioTracks()[0];\n      if (audioTrack) {\n        audioTrack.enabled = !audioTrack.enabled;\n      }\n    }\n  }\n}\n\n// What we're NOT implementing:\n// - Complex signaling protocols (SIP, XMPP)\n// - Multi-party video conferencing\n// - Screen recording\n// - Network quality adaptation\n// - Simulcast/SVC\n// Just simple, reliable P2P connections"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}