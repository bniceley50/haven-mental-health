{"ast":null,"code":"// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = password => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\nconst randomBytes = length => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n\n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n\n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n\n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n  async createDemoAccount() {\n    // Create a demo therapist account\n    const demoEmail = 'demo@haven.health';\n    const demoPassword = 'demo1234';\n    try {\n      await this.register(demoEmail, demoPassword, 'Demo Therapist');\n      console.log('Demo account created successfully');\n    } catch (error) {\n      // Account might already exist\n      console.log('Demo account ready');\n    }\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3,\n      // iterations\n      m: 64 * 1024,\n      // memory in KB\n      p: 1 // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true // Only therapists in this app\n    });\n    return {\n      success: true,\n      email\n    };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1\n    });\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000) // 8 hours\n    };\n    this.sessions.set(sessionId, session);\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return {\n      success: true\n    };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["simpleHash","password","Buffer","from","toString","randomBytes","length","array","Uint8Array","crypto","getRandomValues","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","demoPassword","register","console","log","error","email","name","Error","has","salt","hash","argon2id","t","m","p","set","id","split","concat","createdAt","Date","isTherapist","success","login","attempts","get","user","hashBuffer","slice","storedHash","inputHash","valid","compare","delete","sessionId","session","userId","expiresAt","now","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = (password) => {\n  // Simple hash for demo - NOT for production\n  return Buffer.from(password).toString('base64');\n};\n\nconst randomBytes = (length) => {\n  const array = new Uint8Array(length);\n  crypto.getRandomValues(array);\n  return array;\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  async createDemoAccount() {\n    // Create a demo therapist account\n    const demoEmail = 'demo@haven.health';\n    const demoPassword = 'demo1234';\n    \n    try {\n      await this.register(demoEmail, demoPassword, 'Demo Therapist');\n      console.log('Demo account created successfully');\n    } catch (error) {\n      // Account might already exist\n      console.log('Demo account ready');\n    }\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Hash password with Argon2id (OWASP recommendation)\n    const salt = randomBytes(16);\n    const hash = await argon2id(password, salt, {\n      t: 3, // iterations\n      m: 64 * 1024, // memory in KB\n      p: 1, // parallelism\n    });\n\n    // Store user\n    this.users.set(email, {\n      id: randomBytes(16).toString('hex'),\n      email,\n      name: name || email.split('@')[0],\n      hash: Buffer.concat([salt, hash]).toString('base64'),\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password\n    const hashBuffer = Buffer.from(user.hash, 'base64');\n    const salt = hashBuffer.slice(0, 16);\n    const storedHash = hashBuffer.slice(16);\n    \n    const inputHash = await argon2id(password, salt, {\n      t: 3,\n      m: 64 * 1024,\n      p: 1,\n    });\n\n    const valid = Buffer.compare(inputHash, storedHash) === 0;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = randomBytes(32).toString('hex');\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}