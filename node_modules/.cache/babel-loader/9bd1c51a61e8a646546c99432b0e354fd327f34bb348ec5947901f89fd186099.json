{"ast":null,"code":"// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash=password=>{// Simple hash for demo - NOT for production\n// Using btoa for browser compatibility\nreturn btoa(password);};/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */export class SimpleAuth{constructor(){// In-memory session storage (real app would use secure session management)\nthis.sessions=new Map();// Simple user storage (real app would use encrypted database)\nthis.users=new Map();// Rate limiting for login attempts\nthis.loginAttempts=new Map();// Add demo account for testing\nthis.createDemoAccount();}createDemoAccount(){// Create a demo therapist account directly\nconst demoEmail='demo@haven.health';this.users.set(demoEmail,{id:'demo-user-id',email:demoEmail,name:'Demo Therapist',hash:simpleHash('demo1234'),createdAt:new Date(),isTherapist:true});console.log('Demo account created');}/**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */async register(email,password,name){// Basic validation\nif(!email||!password||password.length<8){throw new Error('Email and password (min 8 chars) required');}// Check if already exists\nif(this.users.has(email)){throw new Error('Account already exists');}// Simple hash for demo\nconst hashedPassword=simpleHash(password);// Store user\nthis.users.set(email,{id:crypto.randomUUID?crypto.randomUUID():Date.now().toString(),email,name:name||email.split('@')[0],hash:hashedPassword,createdAt:new Date(),isTherapist:true// Only therapists in this app\n});return{success:true,email};}/**\n   * Login with rate limiting\n   */async login(email,password){// Check rate limiting\nconst attempts=this.loginAttempts.get(email)||0;if(attempts>=5){throw new Error('Too many login attempts. Try again in 15 minutes.');}// Get user\nconst user=this.users.get(email);if(!user){this.loginAttempts.set(email,attempts+1);throw new Error('Invalid credentials');}// Verify password (simple for demo)\nconst inputHash=simpleHash(password);const valid=inputHash===user.hash;if(!valid){this.loginAttempts.set(email,attempts+1);throw new Error('Invalid credentials');}// Clear login attempts\nthis.loginAttempts.delete(email);// Create session\nconst sessionId=crypto.randomUUID?crypto.randomUUID():Date.now().toString();const session={id:sessionId,userId:user.id,email:user.email,name:user.name,createdAt:new Date(),expiresAt:new Date(Date.now()+8*60*60*1000)// 8 hours\n};this.sessions.set(sessionId,session);return{sessionId,user:{id:user.id,email:user.email,name:user.name}};}/**\n   * Validate session\n   */validateSession(sessionId){const session=this.sessions.get(sessionId);if(!session){return null;}// Check expiration\nif(new Date()>session.expiresAt){this.sessions.delete(sessionId);return null;}// Extend session on activity\nsession.expiresAt=new Date(Date.now()+8*60*60*1000);return{userId:session.userId,email:session.email,name:session.name};}/**\n   * Logout\n   */logout(sessionId){this.sessions.delete(sessionId);return{success:true};}/**\n   * Clean up expired sessions (run periodically)\n   */cleanupSessions(){const now=new Date();for(const[id,session]of this.sessions){if(now>session.expiresAt){this.sessions.delete(id);}}}/**\n   * Reset login attempts (run every 15 minutes)\n   */resetLoginAttempts(){this.loginAttempts.clear();}}// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication.","map":{"version":3,"names":["simpleHash","password","btoa","SimpleAuth","constructor","sessions","Map","users","loginAttempts","createDemoAccount","demoEmail","set","id","email","name","hash","createdAt","Date","isTherapist","console","log","register","length","Error","has","hashedPassword","crypto","randomUUID","now","toString","split","success","login","attempts","get","user","inputHash","valid","delete","sessionId","session","userId","expiresAt","validateSession","logout","cleanupSessions","resetLoginAttempts","clear"],"sources":["C:/Users/brian/OneDrive/Desktop/shadow-sidekick-sqlite-vss-poc/haven-mental-health/src/auth/simple-auth.js"],"sourcesContent":["// For demo purposes, we'll use simple hashing\n// In production, use proper Argon2id\nconst simpleHash = (password) => {\n  // Simple hash for demo - NOT for production\n  // Using btoa for browser compatibility\n  return btoa(password);\n};\n\n/**\n * Simple Authentication for Therapists\n * No complex roles, no organizations, no permissions\n * Just therapist login with secure password hashing\n */\nexport class SimpleAuth {\n  constructor() {\n    // In-memory session storage (real app would use secure session management)\n    this.sessions = new Map();\n    \n    // Simple user storage (real app would use encrypted database)\n    this.users = new Map();\n    \n    // Rate limiting for login attempts\n    this.loginAttempts = new Map();\n    \n    // Add demo account for testing\n    this.createDemoAccount();\n  }\n\n  createDemoAccount() {\n    // Create a demo therapist account directly\n    const demoEmail = 'demo@haven.health';\n    this.users.set(demoEmail, {\n      id: 'demo-user-id',\n      email: demoEmail,\n      name: 'Demo Therapist',\n      hash: simpleHash('demo1234'),\n      createdAt: new Date(),\n      isTherapist: true\n    });\n    console.log('Demo account created');\n  }\n\n  /**\n   * Register a new therapist\n   * Just email and password - no complex onboarding\n   */\n  async register(email, password, name) {\n    // Basic validation\n    if (!email || !password || password.length < 8) {\n      throw new Error('Email and password (min 8 chars) required');\n    }\n\n    // Check if already exists\n    if (this.users.has(email)) {\n      throw new Error('Account already exists');\n    }\n\n    // Simple hash for demo\n    const hashedPassword = simpleHash(password);\n\n    // Store user\n    this.users.set(email, {\n      id: crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(),\n      email,\n      name: name || email.split('@')[0],\n      hash: hashedPassword,\n      createdAt: new Date(),\n      isTherapist: true, // Only therapists in this app\n    });\n\n    return { success: true, email };\n  }\n\n  /**\n   * Login with rate limiting\n   */\n  async login(email, password) {\n    // Check rate limiting\n    const attempts = this.loginAttempts.get(email) || 0;\n    if (attempts >= 5) {\n      throw new Error('Too many login attempts. Try again in 15 minutes.');\n    }\n\n    // Get user\n    const user = this.users.get(email);\n    if (!user) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Verify password (simple for demo)\n    const inputHash = simpleHash(password);\n    const valid = inputHash === user.hash;\n    \n    if (!valid) {\n      this.loginAttempts.set(email, attempts + 1);\n      throw new Error('Invalid credentials');\n    }\n\n    // Clear login attempts\n    this.loginAttempts.delete(email);\n\n    // Create session\n    const sessionId = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString();\n    const session = {\n      id: sessionId,\n      userId: user.id,\n      email: user.email,\n      name: user.name,\n      createdAt: new Date(),\n      expiresAt: new Date(Date.now() + 8 * 60 * 60 * 1000), // 8 hours\n    };\n\n    this.sessions.set(sessionId, session);\n\n    return {\n      sessionId,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n      },\n    };\n  }\n\n  /**\n   * Validate session\n   */\n  validateSession(sessionId) {\n    const session = this.sessions.get(sessionId);\n    \n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (new Date() > session.expiresAt) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Extend session on activity\n    session.expiresAt = new Date(Date.now() + 8 * 60 * 60 * 1000);\n\n    return {\n      userId: session.userId,\n      email: session.email,\n      name: session.name,\n    };\n  }\n\n  /**\n   * Logout\n   */\n  logout(sessionId) {\n    this.sessions.delete(sessionId);\n    return { success: true };\n  }\n\n  /**\n   * Clean up expired sessions (run periodically)\n   */\n  cleanupSessions() {\n    const now = new Date();\n    for (const [id, session] of this.sessions) {\n      if (now > session.expiresAt) {\n        this.sessions.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Reset login attempts (run every 15 minutes)\n   */\n  resetLoginAttempts() {\n    this.loginAttempts.clear();\n  }\n}\n\n// What we're NOT implementing:\n// - OAuth/SSO (complexity)\n// - Two-factor auth (can add later)\n// - Role-based permissions (only therapists)\n// - Organization management (solo focus)\n// - API keys (not needed yet)\n// - Password complexity rules beyond length\n// Just simple, secure therapist authentication."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}